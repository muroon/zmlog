package zmlog

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"

	"github.com/iancoleman/strcase"
)

// ParseAndGenerate parse file and generate new file where the MarshalLogObject methods are written.
func ParseAndGenerate(filePath string) error {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filePath, nil, parser.Mode(0))
	if err != nil {
		return err
	}

	packageName, structs, structFields := getFieldResults(f)

	if len(structs) == 0 {
		return fmt.Errorf("can't generate file because no suitable struct exists. target=%s\n", filePath)
	}

	data := generateFileData(packageName, structs, structFields)
	if data == "" {
		return fmt.Errorf("can't generate file because no suitable struct exists. target=%s\n", filePath)
	}

	genFilePath := strings.Replace(filePath, ".go", "_zap_obj.go", 1)

	_, err = os.Stat(genFilePath)
	if !os.IsNotExist(err) {
		err = os.Remove(genFilePath)
		if err != nil {
			panic(err)
		}
	}

	file, err := os.Create(genFilePath)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	_, err = file.Write([]byte(data))
	if err != nil {
		panic(err)
	}

	fmt.Printf("generate file. %s\n", genFilePath)
	return nil
}

type fieldType int

const (
	normal fieldType = iota
	ptr
	slice
)

type field struct {
	key        string
	fieldName  string
	pkgName    string
	typeName   string
	fieldType  fieldType
	zapFunc    string
	zapFuncErr bool
}

func (f field) allTypeName() string {
	n := f.typeName

	if f.pkgName != "" {
		n = fmt.Sprintf("%s.%s", f.pkgName, f.typeName)
	}

	switch f.fieldType {
	case ptr:
		n = fmt.Sprintf("*%s", n)
	case slice:
		n = fmt.Sprintf("[]%s", n)
	}
	return n
}

func (f field) isEmbedded() bool {
	return f.key == "" && f.allTypeName() != ""
}

func (f field) getKey() string {
	key := ""
	if f.isEmbedded() {
		if f.pkgName != "" {
			key = fmt.Sprintf("%s.%s", f.pkgName, f.typeName)
		} else {
			key = f.typeName
		}
	} else {
		key = f.key
	}
	return strcase.ToSnake(key)
}

func (f field) getFieldName() string {
	if f.isEmbedded() {
		return f.typeName
	}
	return f.fieldName
}

func (f field) getZapFuncParamValue() string {
	fieldName := fmt.Sprintf("l.%s", f.getFieldName())
	if f.fieldType == ptr {
		fieldName = fmt.Sprintf("*l.%s", f.getFieldName())
	}
	return fmt.Sprintf("%s(\"%s\", %s)", f.zapFunc, f.getKey(), fieldName)
}

// generateFileData generate file data
func generateFileData(packageName string, structs []string, structFields map[string][]field) string {
	if len(structs) == 0 {
		return ""
	}

	contents := make([]string, 0, len(structs))
	for _, st := range structs {
		content := generateStructData(st, structFields)
		if content == "" {
			continue
		}

		contents = append(contents, content)
	}
	if len(contents) == 0 {
		return ""
	}

	content := `// Code generated by zap MarshalLogObject generator; DO NOT EDIT.

package %s

import "go.uber.org/zap/zapcore"

%s`
	content = fmt.Sprintf(content, packageName, strings.Join(contents, "\n"))
	return content
}

// generateStructData generate struct data
func generateStructData(structName string, structFields map[string][]field) string {
	if len(structFields[structName]) == 0 {
		return ""
	}

	format := `// MarshalLogObject zapcore.ObjectMarshaler interface method
func (l *%s) MarshalLogObject(enc zapcore.ObjectEncoder) error {
%s	
}
`
	indent := "\t"
	newLine := "\n"

	targetFields := make([]string, 0, len(structFields[structName])+2)

	prefix := fmt.Sprintf("%s%svar err error%s", indent, indent, newLine)
	targetFields = append(targetFields, prefix)

	for _, fie := range structFields[structName] {
		exe := fmt.Sprintf("enc.%s", fie.getZapFuncParamValue())
		if fie.zapFuncErr {
			exe = fmt.Sprintf("err = %s", exe)
		}

		val := fmt.Sprintf("%s%s%s%s", indent, indent, exe, newLine)
		if fie.zapFuncErr {
			exe = "if err != nil { return err }"
			val += fmt.Sprintf("%s%s%s%s", indent, indent, exe, newLine)
		}

		targetFields = append(targetFields, val)
	}
	suffix := fmt.Sprintf("%s%sreturn err", indent, indent)
	targetFields = append(targetFields, suffix)

	return fmt.Sprintf(format, structName, strings.Join(targetFields, ""))
}

// getFieldResults Returns the following information for a struct present in that file using ast
// They are the struct field information of in target file and function information for MarshalLogObject.
func getFieldResults(f *ast.File) (string, []string, map[string][]field) {
	structs := make([]string, 0)
	structFields := make(map[string][]field)

	packageName := f.Name.Name

	ast.Inspect(f, func(n ast.Node) bool {
		if v, ok := n.(*ast.GenDecl); ok {
			for _, s := range v.Specs {
				if t, ok := s.(*ast.TypeSpec); ok {
					if st, ok := t.Type.(*ast.StructType); ok {
						structName := t.Name.String()
						structs = append(structs, structName)
						fields := make([]field, 0)
						if st.Fields != nil {
							for _, fi := range st.Fields.List {
								fie := field{}

								for _, ind := range fi.Names {
									fie.key = strcase.ToSnake(ind.Name)
									fie.fieldName = ind.Name
								}

								// Type
								if fi.Type != nil {
									if ty, ok := fi.Type.(*ast.Ident); ok {
										fie.typeName = ty.Name
									}

									if ty, ok := fi.Type.(*ast.StarExpr); ok {
										fie.fieldType = ptr
										if x, ok := ty.X.(*ast.Ident); ok {
											fie.typeName = x.Name
										}

										// pkg.Struct(time.Timeなど)
										if cty, ok := ty.X.(*ast.SelectorExpr); ok {
											if x, ok := cty.X.(*ast.Ident); ok {
												fie.pkgName = x.Name
											}

											fie.typeName = cty.Sel.Name
										}
									}

									if ty, ok := fi.Type.(*ast.ArrayType); ok {
										fie.fieldType = slice
										if x, ok := ty.Elt.(*ast.Ident); ok {
											fie.typeName = x.Name
										}

										// pkg.Struct(time.Time etc.)
										if cty, ok := ty.Elt.(*ast.SelectorExpr); ok {
											if x, ok := cty.X.(*ast.Ident); ok {
												fie.pkgName = x.Name
											}

											fie.typeName = cty.Sel.Name
										}
									}

									// pkg.Struct(time.Time etc.)
									if ty, ok := fi.Type.(*ast.SelectorExpr); ok {
										if x, ok := ty.X.(*ast.Ident); ok {
											fie.pkgName = x.Name
										}

										fie.typeName = ty.Sel.Name
									}
								}

								// Tag `key:"tag_name"`
								prefixLen := 6
								if fi.Tag != nil && len(fi.Tag.Value) > prefixLen+2 {
									tagName := fi.Tag.Value[prefixLen : len(fi.Tag.Value)-2]
									if fie.key != tagName {
										fie.key = tagName
									}
								}

								fie.zapFunc, fie.zapFuncErr = getZapFunc(fie.allTypeName())
								fields = append(fields, fie)
							}
						}
						structFields[structName] = fields
					}
				}
			}
		}

		return true
	})

	return packageName, structs, structFields
}

// getZapFunc return func name for MarshalLogObject
// reference https://github.com/uber-go/zap/blob/ee349f9e2995499f66628dc573382939b6941b09/zapcore/encoder.go#L349
func getZapFunc(typeName string) (string, bool) {
	switch typeName {
	case "zapcore.ObjectMarshaler":
		return "AddObject", true
	case "zapcore.ArrayMarshaler":
		return "AddArray", true
	case "bool":
		return "AddBool", false
	case "*bool":
		return "AddBool", false
	case "complex128":
		return "AddComplex128", false
	case "*complex128":
		return "AddComplex128", false
	case "complex64":
		return "AddComplex64", false
	case "*complex64":
		return "AddComplex64", false
	case "float64":
		return "AddFloat64", false
	case "*float64":
		return "AddFloat64", false
	case "float32":
		return "AddFloat32", false
	case "*float32":
		return "AddFloat32", false
	case "int":
		return "AddInt", false
	case "*int":
		return "AddInt", false
	case "int64":
		return "AddInt64", false
	case "*int64":
		return "AddInt64", false
	case "int32":
		return "AddInt32", false
	case "*int32":
		return "AddInt32", false
	case "int16":
		return "AddInt16", false
	case "*int16":
		return "AddInt16", false
	case "int8":
		return "AddInt8", false
	case "*int8":
		return "AddInt8", false
	case "string":
		return "AddString", false
	case "*string":
		return "AddString", false
	case "uint":
		return "AddUint", false
	case "*uint":
		return "AddUint", false
	case "uint64":
		return "AddUint64", false
	case "*uint64":
		return "AddUint64", false
	case "uint32":
		return "AddUint32", false
	case "*uint32":
		return "AddUint32", false
	case "uint16":
		return "AddUint16", false
	case "*uint16":
		return "AddUint16", false
	case "uint8":
		return "AddUint8", false
	case "*uint8":
		return "AddUint8", false
	case "[]byte":
		return "AddBinary", false
	case "uintptr":
		return "AddUintptr", false
	case "*uintptr":
		return "AddUintptr", false
	case "time.Time":
		return "AddTime", false
	case "*time.Time":
		return "AddTime", false
	case "time.Duration":
		return "AddDuration", false
	case "*time.Duration":
		return "AddDuration", false
	default:
		return "AddReflected", true
	}
}
